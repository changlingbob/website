function X(e){return Array.from(new Set(e))}const Z="0.4.168",L={projectName:"Vike",projectVersion:Z},C=`_${L.projectName.toLowerCase()}`;function j(e,t){const n=M();return n[e]=n[e]||t}function M(){return globalThis[C]=globalThis[C]||{}}const d=j("assertPackageInstances.ts",{instances:[],alreadyLogged:new Set}),ee="The client runtime of Server Routing as well as the client runtime of Client Routing are both being loaded. Make sure they aren't loaded both at the same time for a given page. See https://vike.dev/client-runtimes-conflict",V="Two vike client runtime instances are being loaded. Make sure your client-side bundles don't include vike twice. (In order to reduce the size of your client-side JavaScript bundles.)";function z(){{const e=X(d.instances);ne(e.length<=1,`Both vike@${e[0]} and vike@${e[1]} loaded. Only one version should be loaded.`)}d.checkSingleInstance&&d.instances.length>1&&T(!1,V,{onlyOnce:!0,showStackTrace:!0})}function Ae(e){T(d.isClientRouting!==!1,ee,{onlyOnce:!0,showStackTrace:!0}),T(d.isClientRouting===void 0,V,{onlyOnce:!0,showStackTrace:!0}),d.isClientRouting=!0,e&&(d.checkSingleInstance=!0),z()}function te(){d.instances.push(L.projectVersion),z()}function ne(e,t){if(e)return;const n=`[vike][Wrong Usage] ${t}`;throw new Error(n)}function T(e,t,{onlyOnce:n,showStackTrace:r}){if(e)return;const i=`[vike][Warning] ${t}`;if(n){const{alreadyLogged:o}=d,a=n===!0?i:n;if(o.has(a))return;o.add(a)}console.warn(r?new Error(i):i)}function re(){return!(typeof process>"u"||!process.cwd||!process.versions||typeof process.versions.node>"u"||!process.release||process.release.name!=="node")}function E(e,t){let n;{var r=Error.stackTraceLimit;Error.stackTraceLimit=1/0,n=new Error(e),Error.stackTraceLimit=r}return re()&&(n.stack=ie(n.stack,t)),n}function ie(e,t){if(!e)return e;const n=se(e);let r=0;return n.filter(o=>o.includes(" (internal/")||o.includes(" (node:internal")?!1:r<t&&oe(o)?(r++,!1):!0).join(`
`)}function oe(e){return e.startsWith("    at ")}function se(e){return e.split(/\r?\n/)}function R(e){return typeof e=="object"&&e!==null}const u=new Proxy(e=>e,{get:()=>u}),c=j("utils/assert.ts",{alreadyLogged:new Set,logger(e,t){t==="info"?console.log(e):console.warn(e)},showStackTraceList:new WeakSet});te();const ae="[vike]",ce=`[vike@${L.projectVersion}]`,O=2;function s(e,t){var o;if(e)return;const n=(()=>{if(!t)return null;const a=typeof t=="string"?t:JSON.stringify(t);return u.dim(`Debug info (for Vike maintainers; you can ignore this): ${a}`)})();let r=["You stumbled upon a Vike bug.",`Go to ${u.blue("https://github.com/vikejs/vike/issues/new")} and copy-paste this error. A maintainer will fix the bug (usually under 24 hours).`,n].filter(Boolean).join(" ");r=y(r),r=v(r,"Bug"),r=b(r,!0);const i=E(r,O);throw(o=c.onBeforeLog)==null||o.call(c),i}function w(e,t,{showStackTrace:n}={}){var i;if(e)return;t=y(t),t=v(t,"Wrong Usage"),t=b(t);const r=E(t,O);throw n&&c.showStackTraceList.add(r),(i=c.onBeforeLog)==null||i.call(c),r}function ue(e){return e=y(e),e=v(e,"Error"),e=b(e),E(e,O)}function A(e,t,{onlyOnce:n,showStackTrace:r}){var i;if(!e){if(t=y(t),t=v(t,"Warning"),t=b(t),n){const{alreadyLogged:o}=c,a=n===!0?t:n;if(o.has(a))return;o.add(a)}if((i=c.onBeforeLog)==null||i.call(c),r){const o=new Error(t);c.showStackTraceList.add(o),c.logger(o,"warn")}else c.logger(t,"warn")}}function le(e,t,{onlyOnce:n}){var r;if(!e){if(t=y(t),t=b(t),n){const{alreadyLogged:i}=c,o=t;if(i.has(o))return;i.add(o)}(r=c.onBeforeLog)==null||r.call(c),c.logger(t,"info")}}function v(e,t){let n=`[${t}]`;const r=t==="Warning"?"yellow":"red";return n=u.bold(u[r](n)),`${n}${e}`}function y(e){return e.startsWith("[")?e:` ${e}`}function b(e,t=!1){return`${t?ce:ae}${e}`}function I(e){const t=e/1e3;if(t<120){const n=_(t);return`${n} second${P(n)}`}{const n=t/60,r=_(n);return`${r} minute${P(r)}`}}function _(e){let t=e.toFixed(1);return t.endsWith(".0")&&(t=t.slice(0,-2)),t}function P(e){return e==="1"?"":"s"}const F=j("utils/executeHook.ts",{userHookErrors:new WeakMap});function fe(e){return R(e)?F.userHookErrors.get(e)??!1:!1}function Ue(e,t){const{hookName:n,hookFilePath:r,hookTimeout:{error:i,warning:o}}=t;let a,h;const g=new Promise((l,$)=>{a=p=>{k(),l(p)},h=p=>{k(),$(p)}}),k=()=>{m&&clearTimeout(m),f&&clearTimeout(f)},m=B(o)&&setTimeout(()=>{A(!1,`The ${n}() hook defined by ${r} is slow: it's taking more than ${I(o)} (https://vike.dev/hooksTimeout)`,{onlyOnce:!1})},o),f=B(i)&&setTimeout(()=>{const l=ue(`The ${n}() hook defined by ${r} timed out: it didn't finish after ${I(i)} (https://vike.dev/hooksTimeout)`);h(l)},i);return(async()=>{try{const l=await e();a(l)}catch(l){R(l)&&F.userHookErrors.set(l,{hookName:n,hookFilePath:r}),h(l)}})(),g}function B(e){return!!e&&e!==1/0}function J(){return typeof window<"u"&&typeof window.scrollY=="number"}const D=j("utils/assertRouterType.ts",{});function he(){pe(de()),D.isClientRouting=!0}function de(){return D.isClientRouting!==!1}function pe(e){w(J(),`${u.cyan("import { something } from 'vike/client/router'")} is forbidden on the server-side`,{showStackTrace:!0}),A(e,"You shouldn't `import { something } from 'vike/client/router'` when using Server Routing. The 'vike/client/router' utilities work only with Client Routing. In particular, don't `import { navigate }` nor `import { prefetch }` as they unnecessarily bloat your client-side bundle sizes.",{showStackTrace:!0,onlyOnce:!0})}function ge(e){return e instanceof Function||typeof e=="function"}function me(e,t,n="unknown"){if(!R(e))return!1;if(!(t in e))return n==="undefined";if(n==="unknown")return!0;const r=e[t];return n==="array"?Array.isArray(r):n==="object"?R(r):n==="string[]"?Array.isArray(r)&&r.every(i=>typeof i=="string"):n==="function"?ge(r):Array.isArray(n)?typeof r=="string"&&n.includes(r):n==="null"?r===null:n==="undefined"?r===void 0:n==="true"?r===!0:n==="false"?r===!1:typeof r===n}function G(e,t){t&&Object.defineProperties(e,Object.getOwnPropertyDescriptors(t))}function N(e,t,n){return typeof e=="string"?x(e.split(""),t,n).join(""):x(e,t,n)}function x(e,t,n){const r=[];let i=t>=0?t:e.length+t;s(i>=0&&i<=e.length);let o=n>=0?n:e.length+n;for(s(o>=0&&o<=e.length);!(i===o||(i===e.length&&(i=0),i===o));){const a=e[i];s(a!==void 0),r.push(a),i++}return r}const Y=["http://","https://","tauri://","file://"];function q(e){return Y.some(t=>e.startsWith(t))||e.startsWith("/")||e.startsWith(".")||e.startsWith("?")||e.startsWith("#")||e===""}function Ce(e,t){s(t.includes(" but ")),w(typeof e=="string",`${t} should be a string`),!q(e)&&(!e.startsWith("/")&&!e.includes(":")?w(!1,`${t} is ${u.cyan(e)} and it should be /${u.cyan(e)} instead (URL pathnames should start with a leading slash)`):w(!1,`${t} isn't a valid URL`))}function Ie(e,t){s(q(e)),s(t.startsWith("/"));const[n,...r]=e.split("#");s(n!==void 0);const i=["",...r].join("#")||null;s(i===null||i.startsWith("#"));const o=i===null?"":S(i.slice(1)),[a,...h]=n.split("?");s(a!==void 0);const g=["",...h].join("?")||null;s(g===null||g.startsWith("?"));const k={},m={};Array.from(new URLSearchParams(g||"")).forEach(([W,U])=>{k[W]=U,m[W]=[...m.hasOwnProperty(W)?m[W]:[],U]});const{origin:f,pathname:l}=ke(a,t);s(f===null||f===S(f)),s(l.startsWith("/")),s(f===null||e.startsWith(f));const $=a.slice((f||"").length);Re(e,f,$,g,i);let{pathname:p,hasBaseServer:Q}=$e(l,t);return p=we(p),s(p.startsWith("/")),{origin:f,pathname:p,pathnameOriginal:$,hasBaseServer:Q,search:k,searchAll:m,searchOriginal:g,hash:o,hashOriginal:i}}function S(e){try{return decodeURIComponent(e)}catch{}try{return decodeURI(e)}catch{}return e}function we(e){return e=e.replace(/\s+$/,""),e=e.split("/").map(t=>S(t).split("/").join("%2F")).join("/"),e}function ke(e,t){var n;s(!e.includes("?")&&!e.includes("#"));{const{origin:r,pathname:i}=H(e);if(r)return{origin:r,pathname:i};s(i===e)}if(e.startsWith("/"))return{origin:null,pathname:e};{const r=typeof window<"u"?(n=window==null?void 0:window.document)==null?void 0:n.baseURI:void 0;let i;return r?i=H(r.split("?")[0]).pathname:i=t,{origin:null,pathname:ye(e,i)}}}function H(e){if(Y.some(t=>e.startsWith(t))){const[t,n,r,...i]=e.split("/"),o=[t,n,r].join("/"),a=["",...i].join("/")||"/";return{origin:o,pathname:a}}else return{pathname:e,origin:null}}function ye(e,t){const n=t.split("/"),r=e.split("/");let i=t.endsWith("/");e.startsWith(".")&&n.pop();for(const a in r){const h=r[a];h==""&&a==="0"||h!="."&&(h==".."?n.pop():(i=!1,n.push(h)))}let o=n.join("/");return i&&!o.endsWith("/")&&(o+="/"),o.startsWith("/")||(o="/"+o),o}function be(e){s(e.startsWith("/")),s(!e.includes("?")),s(!e.includes("#"))}function $e(e,t){be(e),s(We(t));let n=e;if(s(n.startsWith("/")),s(t.startsWith("/")),t==="/")return{pathname:e,hasBaseServer:!0};let r=t;return t.endsWith("/")&&n===N(t,0,-1)&&(r=N(t,0,-1),s(n===r)),n.startsWith(r)?(s(n.startsWith("/")||n.startsWith("http")),s(n.startsWith(r)),n=n.slice(r.length),n.startsWith("/")||(n="/"+n),s(n.startsWith("/")),{pathname:n,hasBaseServer:!0}):{pathname:e,hasBaseServer:!1}}function We(e){return e.startsWith("/")}function Re(e,t,n,r,i){const o=je(t,n,r,i);s(e===o)}function je(e,t,n,r){return`${e||""}${t}${n||""}${r||""}`}function ve(e){return/^[a-z0-9][a-z0-9\.\+\-]*:/i.test(e)}function Te(e,t,n=r=>r){if(s(e.length>0),e.length===1)return n(e[0]);const r=e.slice(0,e.length-1),i=e[e.length-1];return r.map(n).join(", ")+` ${t} `+n(i)}J()&&he();function _e(e,t){const n="throw redirect()";Oe(e,n,!0);const r=[JSON.stringify(e)];t?(Le(t,[301,302],"redirect"),r.push(String(t))):t=302;const i={};return G(i,{_abortCaller:n,_abortCall:`redirect(${r.join(", ")})`,_urlRedirect:{url:e,statusCode:t}}),Se(i)}function Se(e){const t=new Error("AbortRender");return G(t,{_pageContextAbort:e,[K]:!0}),t}const K="_isAbortError";function Pe(e){return typeof e=="object"&&e!==null&&K in e}function Be(e){return e._urlRewrite||e._urlRedirect||e.abortStatusCode?(s(me(e,"_abortCall","string")),!0):!1}function Ne(e,t,n){if(t)return;const r=n._urlRewrite??n.urlOriginal;s(r);const i=e._pageContextAbort._abortCall;s(i);const o=fe(e);let a="";o&&(a=` by ${u.cyan(`${o.hookName}()`)} hook defined at ${o.hookFilePath}`),le(!1,`${u.cyan(i)} thrown${a} while rendering ${u.cyan(r)}`,{onlyOnce:!1})}function Le(e,t,n){const r=Te(t.map(i=>i.toString()),"or");A(t.includes(e),`Unepexected status code ${e} passed to ${n}(), we recommend ${r} instead. (Or reach out at https://github.com/vikejs/vike/issues/1008 if you believe ${e} should be added.)`,{onlyOnce:!0})}function xe(e){Ee(e);const t={_urlRewrite:null};return e.forEach(n=>{Object.assign(t,n)}),t}function Ee(e){const t=[];e.forEach(n=>{const r=n._urlRewrite;{const i=t.indexOf(r);if(i!==-1){const o=[...t.slice(i),r].map(a=>`render('${a}')`).join(" => ");w(!1,`Infinite loop of render() calls: ${o}`)}}t.push(r)})}function He(e,t){const n=[e>0&&u.cyan("throw render('/some-url')"),t>0&&u.cyan("throw redirect('/some-url')")].filter(Boolean).join(" and ");w(e+t<=7,`Maximum chain length of 7 ${n} exceeded. Did you define an infinite loop of ${n}?`)}function Oe(e,t,n){w(e.startsWith("/")||n&&ve(e),[`Invalid URL ${u.cyan(e)} passed to ${u.cyan(t)}:`,`the URL should start with ${u.cyan("/")}`,n&&`or a valid protocol (${u.cyan("https:")}, ${u.cyan("ipfs:")}, ...)`].filter(Boolean).join(" "))}export{Se as A,Ne as B,Ae as C,s as a,w as b,R as c,J as d,A as e,he as f,j as g,me as h,ge as i,Ue as j,Be as k,ue as l,We as m,q as n,G as o,Ie as p,le as q,_e as r,N as s,Te as t,X as u,u as v,Ce as w,He as x,xe as y,Pe as z};
